<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<meta name="color-scheme" content="dark" />
<title>بكفي — Retro Space Shooter (drops+smooth move — fixed)</title>
<style>
  html,body{margin:0;height:100%;background:#000;color:#e7eefc}
  #stage{position:fixed; inset:0; overflow:hidden; touch-action:none}
  canvas{display:block; width:100vw; height:100vh; background:#000; image-rendering:pixelated; direction:ltr}
  .crt{position:absolute; inset:0; pointer-events:none;
       background:repeating-linear-gradient(to bottom, rgba(255,255,255,.03) 0 1px, rgba(0,0,0,0) 1px 3px);
       mix-blend-mode:overlay;}
</style>
</head>
<body>
<div id="stage">
  <canvas id="game"></canvas>
  <div class="crt"></div>
</div>

<script>
/* ============================================================
   Fixes:
   - meta viewport uses maximum-scale (not "maximum")
   - Powerup halo: guard createRadialGradient against non-finite values
     (defaults renderY to y; checks via Number.isFinite)
   - nextEnemyTime simplified
============================================================ */

// ---------- Canvas ----------
const stage=document.getElementById('stage');
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d', {alpha:true, willReadFrequently:true});
let DPR=1, W=960, H=540;

function _resizeNow(){
  DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  W = Math.floor(window.innerWidth); H = Math.floor(window.innerHeight);
  canvas.width = Math.floor(W*DPR); canvas.height = Math.floor(H*DPR);
  canvas.style.width=W+"px"; canvas.style.height=H+"px";
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.imageSmoothingEnabled=false;
  layoutWordFit();
}
let _rzId=0;
function resize(){ cancelAnimationFrame(_rzId); _rzId=requestAnimationFrame(_resizeNow); }
addEventListener('resize', resize);

// ---------- Env & tuning ----------
const IS_TOUCH=('ontouchstart' in window)||navigator.maxTouchPoints>0||matchMedia('(pointer: coarse)').matches;
const pal={ wall:"#1b2030", brick:"#ff3b3b", ship:"#aef59a", bullet:"#ffffff",
            debris:"#ff3b3b", enemy:"#b687ff", powRapid:"#6ecbff", powShield:"#ffd166" };

const BASE_BLOCK=12, BASE_GAP=1, CELL=BASE_BLOCK+BASE_GAP;
const TOP_FRACTION=0.09;

const SHIP_MAX_SPEED=520, SHIP_ACCEL=3000, SHIP_FRICTION=2200;
const BASE_COOLDOWN=0.12, RAPID_COOLDOWN=0.06;

const DEBRIS_CHANCE=0.25;
const DROP_CHANCE=0.10;

const SHAKE_HIT=0.01, SHAKE_DECAY=1.4;

const ENEMY_MIN_INTERVAL=IS_TOUCH?2.8:2.4;
const ENEMY_MAX_INTERVAL=IS_TOUCH?4.6:4.0;
const ENEMY_MAX_ACTIVE=IS_TOUCH?4:5;

const SHIP_PAD_FRAC = IS_TOUCH ? 0.20 : 0.18;
function shipBaselineY(){ return Math.round(H * (1 - SHIP_PAD_FRAC)); }

// --- Powerup magnet & sparkle tuning ---
const MAGNET_RADIUS = 140;
const MAGNET_STRENGTH = 900;
const SPARKLE_RATE = 18;

// ---------- State ----------
let stars=[], bricks=[], bullets=[], debris=[], particles=[], enemies=[], powerups=[];
let ship, score=0, lives=5, state="play", t=0, lastTs=0, shake=0, winTimer=0, rapidTime=0, hasShield=false, invuln=0;
const keys={};
let pointerDown=false, pointerX=null, pointerSmoothedX=null, lastTap=0;

// ---------- Offscreen word raster ("بكفي") ----------
const fontStack='"Noto Naskh Arabic","Scheherazade New","Amiri","Segoe UI Historic","Arial","sans-serif"';
let baseBricks=[], baseWidth=1, baseHeight=1, minC=0, minR=0;

function buildWordGrid(word="بكفي"){
  baseBricks.length=0;
  const off=document.createElement('canvas'); off.width=1600; off.height=520;
  const g=off.getContext('2d', {alpha:true, willReadFrequently:true});

  g.clearRect(0,0,off.width,off.height);
  g.fillStyle="#fff"; g.textAlign="center"; g.textBaseline="middle"; g.direction="rtl";
  g.font=`bold 360px ${fontStack}`;
  g.fillText(word, off.width/2, off.height/2 + 6);

  const data=g.getImageData(0,0,off.width,off.height).data;
  const cols=Math.floor(off.width/CELL), rows=Math.floor(off.height/CELL);

  let cMin=cols, rMin=rows, cMax=-1, rMax=-1;
  const occupied=[];
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const baseX=c*CELL, baseY=r*CELL;
      const samples=[[0.5,0.5],[0.2,0.5],[0.8,0.5],[0.5,0.2],[0.5,0.8]];
      let on=false;
      for(const [ux,uy] of samples){
        const px=Math.min(off.width-1, Math.floor(baseX + ux*BASE_BLOCK));
        const py=Math.min(off.height-1, Math.floor(baseY + uy*BASE_BLOCK));
        const a=data[(py*off.width+px)*4+3];
        if(a>32){ on=true; break; }
      }
      if(on){
        occupied.push({c,r});
        if(c<cMin) cMin=c; if(r<rMin) rMin=r;
        if(c>cMax) cMax=c; if(r>rMax) rMax=r;
      }
    }
  }

  if(occupied.length<50){
    occupied.length=0; cMin=cols; rMin=rows; cMax=-1; rMax=-1;
    g.clearRect(0,0,off.width,off.height);
    g.fillStyle="#fff"; g.font=`bold 420px ${fontStack}`;
    g.fillText(word, off.width/2, off.height/2 + 8);
    const d2=g.getImageData(0,0,off.width,off.height).data;
    for(let r=0;r<rows;r++)for(let c=0;c<cols;c++){
      const px=Math.min(off.width-1, Math.floor(c*CELL + BASE_BLOCK*0.5));
      const py=Math.min(off.height-1, Math.floor(r*CELL + BASE_BLOCK*0.5));
      if(d2[(py*off.width+px)*4+3]>16){
        occupied.push({c,r});
        if(c<cMin) cMin=c; if(r<rMin) rMin=r;
        if(c>cMax) cMax=c; if(r>rMax) rMax=r;
      }
    }
  }

  minC=cMin; minR=rMin;
  baseBricks = occupied.map(({c,r})=>({ x:(c-minC)*CELL, y:(r-minR)*CELL, w:BASE_BLOCK, h:BASE_BLOCK, alive:true }));
  baseWidth  = (cMax - cMin + 1) * CELL;
  baseHeight = (rMax - rMin + 1) * CELL;

  if(!isFinite(baseWidth)||baseWidth<=0){ baseWidth=BASE_BLOCK*10; baseHeight=BASE_BLOCK*6; }
}

// fit & placement
let wordScale=1, wordOffX=0, wordOffY=0;
function layoutWordFit(){
  if(!baseWidth) return;
  const fitW=W*0.92, fitH=H*(IS_TOUCH?0.50:0.55);
  wordScale = Math.min(fitW/baseWidth, fitH/baseHeight);
  const top=Math.floor(H*TOP_FRACTION);
  const wpx=baseWidth*wordScale, hpx=baseHeight*wordScale;
  wordOffX=Math.floor((W-wpx)/2);
  wordOffY=Math.floor(top + (fitH-hpx)/2);
}
function instantiateBricks(){ bricks = baseBricks.map(b=>({bx:b.x,by:b.y,w:b.w,h:b.h,alive:true})); }

// ---------- Helpers ----------
function rectHit(ax,ay,aw,ah,bx,by,bw,bh){return ax<bx+bw&&ax+aw>bx&&ay<by+bh&&ay+ah>by;}

// ---------- Stars ----------
function buildStars(){
  stars.length=0;
  const n=Math.min(5000, Math.round((W*H)/9000));
  for(let i=0;i<n;i++) stars.push({x:Math.random()*W,y:Math.random()*H,z:Math.random()*2+0.5});
}

// ---------- Enemies & Powerups ----------
let enemyTimer=0;
function nextEnemyTime(){ return ENEMY_MIN_INTERVAL + Math.random()*(ENEMY_MAX_INTERVAL-ENEMY_MIN_INTERVAL); }
function spawnEnemy(){
  const side=Math.random()<0.5?-40:W+40, y=30+Math.random()*60, dir=side<0?1:-1;
  enemies.push({x:side,y,w:16,h:12,vx:80*dir,vy:24,state:"home",t:0,alive:true, trail:[]});
}
function dropPowerup(x,y){
  const type=Math.random()<0.5?"shield":"rapid";
  // renderY initialized to y so it's finite on first frame
  powerups.push({x,y,renderY:y,w:12,h:12,vy:120+Math.random()*80,vx:(Math.random()*50-25),type,alive:true,a:0,seed:Math.random()*6.283,lastSparkle:0});
}

// ---------- Audio ----------
let audioCtx;
function ensureAudio(){try{
  audioCtx = audioCtx || new (window.AudioContext||window.webkitAudioContext)();
  audioCtx.resume?.();
}catch{}}
function blip(f=440,d=0.05){try{
  audioCtx=audioCtx||new (window.AudioContext||window.webkitAudioContext)();
  const o=audioCtx.createOscillator(), g=audioCtx.createGain();
  o.type="square"; o.frequency.value=f; g.gain.value=0.05; o.connect(g); g.connect(audioCtx.destination);
  o.start(); g.gain.exponentialRampToValueAtTime(0.0001,audioCtx.currentTime+d); o.stop(audioCtx.currentTime+d);
}catch{}}

// ---------- Reset / Init ----------
function hardReset(){
  score=0; lives=5; state="play"; t=0; shake=0; winTimer=0; rapidTime=0; hasShield=false; invuln=0;
  ship={x:W/2,y:shipBaselineY(),w:28,h:18,vx:0,cooldown:0};
  instantiateBricks(); buildStars();
  bullets.length=debris.length=particles.length=enemies.length=powerups.length=0;
  enemyTimer=nextEnemyTime();
}
function init(){
  _resizeNow();
  buildWordGrid("بكفي");
  layoutWordFit();
  hardReset();
}
document.addEventListener('DOMContentLoaded', init);

// ---------- Input ----------
addEventListener('keydown',e=>{
  keys[e.code]=true; if(e.code==='Space') e.preventDefault();
  if(e.code==='KeyR') hardReset();
  if(e.code==='KeyF'){ if(!document.fullscreenElement) stage.requestFullscreen?.(); else document.exitFullscreen?.(); }
});
addEventListener('keyup',e=>keys[e.code]=false);
stage.addEventListener('pointerdown',e=>{
  ensureAudio();
  const now=performance.now();
  if(now-lastTap<300){ if(!document.fullscreenElement) stage.requestFullscreen?.(); else document.exitFullscreen?.(); }
  lastTap=now;
  pointerDown=true; pointerX=e.clientX; pointerSmoothedX=e.clientX;
  stage.setPointerCapture?.(e.pointerId);
});
stage.addEventListener('pointermove',e=>{ if(pointerDown){ pointerX=e.clientX; } });
stage.addEventListener('pointerup',()=>{ pointerDown=false; pointerX=null; });
stage.addEventListener('click',()=>{
  if(state==="over" || (state==="win" && winTimer>0.5)) hardReset();
});

// ---------- Game update ----------
function hitPlayer(){
  if(invuln>0) return;
  if(hasShield){ hasShield=false; blip(180,.08); invuln=0.8; return; }
  lives--; blip(120,.12); shake=Math.max(shake, SHAKE_HIT*1.5); invuln=0.8;
  if(lives<=0) state="over"; else { ship.x=W/2; ship.vx=0; bullets.length=0; }
}

function collectPowerup(p){ if(p.type==="shield") hasShield=true; else rapidTime=8.0; }

function update(dt){
  if(state!=="play" && state!=="win") return;
  t+=dt; if(invuln>0) invuln-=dt;

  // stars
  for(let i=0;i<stars.length;i++){ const s=stars[i]; s.y += (state==="win"?10:20)*s.z*dt; if(s.y>H) s.y-=H; }

  // Smooth movement (EMA + deadzone)
  let targetVel = 0;
  if(pointerDown && pointerX!=null){
    if(pointerSmoothedX==null) pointerSmoothedX=pointerX;
    pointerSmoothedX += (pointerX - pointerSmoothedX) * 0.22;
    const dx = pointerSmoothedX - ship.x;
    const dead = 2.5;
    const adjDx = Math.abs(dx) < dead ? 0 : dx;
    targetVel = Math.max(-SHIP_MAX_SPEED, Math.min(SHIP_MAX_SPEED, adjDx * 6));
  } else {
    if(keys.ArrowLeft||keys.KeyA) targetVel -= SHIP_MAX_SPEED;
    if(keys.ArrowRight||keys.KeyD) targetVel += SHIP_MAX_SPEED;
  }
  const accel = (targetVel===0 ? SHIP_FRICTION : SHIP_ACCEL) * dt;
  const delta = targetVel - ship.vx;
  ship.vx += Math.max(-accel, Math.min(accel, delta));
  if(!pointerDown && !(keys.ArrowLeft||keys.KeyA||keys.ArrowRight||keys.KeyD)){
    const s=Math.sign(ship.vx); ship.vx -= s*Math.min(Math.abs(ship.vx), SHIP_FRICTION*dt*0.6);
  }
  ship.x=Math.max(20,Math.min(W-20, ship.x + ship.vx*dt));
  ship.y = shipBaselineY();

  // shooting
  const cd = rapidTime>0 ? RAPID_COOLDOWN : BASE_COOLDOWN;
  if(ship.cooldown>0) ship.cooldown-=dt;
  if(state==="play" && ship.cooldown<=0 && (keys.Space || pointerDown)){
    bullets.push({x:ship.x,y:ship.y-12,w:3,h:10,vy:-700,life:1});
    ship.cooldown=cd; blip(900,.05);
  }
  if(rapidTime>0) rapidTime-=dt;

  // bullets (compact)
  let write=0;
  for(let i=0;i<bullets.length;i++){
    const b=bullets[i];
    b.y+=b.vy*dt; b.life-=dt*0.9;
    if(b.y>-20 && b.life>0) bullets[write++]=b;
  }
  bullets.length=write;

  // drift
  const wdx=Math.sin(t*0.55)*18, wdy=Math.sin(t*1.05)*3;

  // bullet vs bricks
  for(let bi=0; bi<bricks.length; bi++){
    const br=bricks[bi]; if(!br.alive) continue;
    const bx=wordOffX + br.bx*wordScale + wdx;
    const by=wordOffY + br.by*wordScale + wdy;
    const bw=br.w*wordScale, bh=br.h*wordScale;

    for(let i=0;i<bullets.length;i++){
      const bu=bullets[i];
      if(bu.x>bx && bu.x<bx+bw && bu.y>by && bu.y<by+bh){
        br.alive=false; bu.y=-9999; score+=10; blip(240,.04); shake=Math.min(0.06, shake+SHAKE_HIT);
        particles.push({x:bx,y:by,w:bw,h:bh,type:"flash",life:.08});
        for(let k=0;k<6;k++){
          const ang=Math.random()*6.283, spd=140+Math.random()*220, sz=1+Math.random()*2;
          particles.push({x:bx+bw/2,y:by+bh/2,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,sz,life:.5+Math.random()*.35,col:pal.brick,type:"shard"});
        }
        for(let k=0;k<10;k++){
          const ang=Math.random()*6.283, spd=90+Math.random()*160;
          particles.push({x:bx+bw/2,y:by+bh/2,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,life:.55+Math.random()*.35,col:k%2?pal.brick:"#ffd7d7",type:"pix"});
        }
        if(Math.random()<DEBRIS_CHANCE)
          debris.push({x:bx+bw/2,y:by+bh/2,w:7,h:7,vy:220+Math.random()*190,vx:(Math.random()*90-45),a:0,spin:(Math.random()*.4-.2),alive:true,px:bx+bw/2,py:by+bh/2});
        if(Math.random()<DROP_CHANCE) dropPowerup(bx+bw/2, by+bh/2);
        break;
      }
    }
  }

  // debris
  write=0;
  for(let i=0;i<debris.length;i++){
    const d=debris[i];
    d.px = d.x; d.py = d.y;
    d.x+=d.vx*dt; d.y+=d.vy*dt; d.a+=d.spin;
    if(state==="play" && rectHit(ship.x-12,ship.y-10,24,20,d.x-d.w/2,d.y-d.h/2,d.w,d.h)){ d.alive=false; hitPlayer(); }
    if(d.alive && d.y<H+20) debris[write++]=d;
  }
  debris.length=write;

  // powerups
  write=0;
  for(let i=0;i<powerups.length;i++){
    const p=powerups[i];
    const bob = Math.sin(t*2 + p.seed)*10;
    p.x+=p.vx*dt; p.y+=p.vy*dt; p.a=(p.a||0)+0.08;
    p.renderY = p.y + bob;

    // magnet
    const dx = ship.x - p.x, dy = ship.y - p.y;
    const dist = Math.hypot(dx,dy);
    if(dist < MAGNET_RADIUS){
      const ux = dx/(dist||1), uy = dy/(dist||1);
      const pull = (1 - dist/MAGNET_RADIUS);
      p.vx += ux * MAGNET_STRENGTH * pull * dt;
      p.vy += uy * MAGNET_STRENGTH * pull * dt;
    }

    // pickup
    if(rectHit(ship.x-12,ship.y-10,24,20,p.x-p.w/2,p.renderY-p.h/2,p.w,p.h)){ p.alive=false; collectPowerup(p); blip(700,.06); }

    // sparkles
    p.lastSparkle += dt*SPARKLE_RATE;
    while(p.lastSparkle>=1){
      p.lastSparkle -= 1;
      const ang=Math.random()*6.283, spd=40+Math.random()*80;
      particles.push({x:p.x, y:p.renderY, vx:Math.cos(ang)*spd, vy:Math.sin(ang)*spd, life:.5+Math.random()*.3, col:(p.type==="shield"?"#ffefaa":"#aee7ff"), type:"pix"});
    }

    if(p.alive && p.renderY<H+24) powerups[write++]=p;
  }
  powerups.length=write;

  // enemies
  if(state==="play"){ enemyTimer-=dt; if(enemyTimer<=0 && enemies.filter(e=>e.alive).length<ENEMY_MAX_ACTIVE){ spawnEnemy(); enemyTimer=nextEnemyTime(); } }
  write=0;
  for(let i=0;i<enemies.length;i++){
    const e=enemies[i]; if(!e.alive){ continue; }
    e.t+=dt;

    e.trail.push({x:e.x,y:e.y,life:0.25});
    if(e.trail.length>10) e.trail.shift();
    for(let j=0;j<e.trail.length;j++){ e.trail[j].life -= dt; }

    const dx=ship.x-e.x, dy=(ship.y-40)-e.y, dist=Math.hypot(dx,dy)+1e-3, ux=dx/dist, uy=dy/dist;
    if(e.state==="home"){ e.vx+=ux*80*dt; e.vy+=uy*60*dt; if(e.t>1.1 && Math.random()<0.02) e.state="dive"; }
    else { e.vx+=ux*130*dt; e.vy+=uy*170*dt; }
    const sp=Math.hypot(e.vx,e.vy), max=(e.state==="dive"?240:165); if(sp>max){ e.vx=e.vx/sp*max; e.vy=e.vy/sp*max; }
    e.x+=e.vx*dt; e.y+=e.vy*dt; if(e.x<-60||e.x>W+60||e.y>H+60) e.alive=false;

    for(let b=0;b<bullets.length;b++){
      const bu=bullets[b];
      if(bu.x>e.x-e.w/2&&bu.x<e.x+e.w/2&&bu.y>e.y-e.h/2&&bu.y<e.y+e.h/2){
        e.alive=false; bu.y=-9999; score+=15; blip(300,.05); shake=Math.min(0.06, shake+SHAKE_HIT*0.8);
        for(let k=0;k<14;k++){ const a=Math.random()*6.283, spd=100+Math.random()*180; particles.push({x:e.x,y:e.y,vx:Math.cos(a)*spd,vy:Math.sin(a)*spd,life:.5+Math.random()*.4,col:pal.enemy,type:"pix"}); }
        if(Math.random()<0.08) dropPowerup(e.x,e.y);
        break;
      }
    }
    if(state==="play" && e.alive && rectHit(ship.x-12,ship.y-10,24,20,e.x-e.w/2,e.y-e.h/2,e.w,e.h)){ e.alive=false; hitPlayer(); }

    if(e.alive) enemies[write++]=e;
  }
  enemies.length=write;

  // particles
  write=0;
  for(let i=0;i<particles.length;i++){
    const p=particles[i];
    if(p.type==="flash"){ p.life-=dt; if(p.life>0) particles[write++]=p; continue; }
    p.x+=p.vx*dt; p.y+=p.vy*dt; p.vy += (p.type==="shard"?120:40)*dt;
    p.life-=dt;
    if(p.life>0) particles[write++]=p;
  }
  particles.length=write;

  // win?
  if(state==="play" && !bricks.some(b=>b.alive)){ state="win"; winTimer=0; blip(660,.1); blip(990,.12); }
  if(state==="win"){ winTimer+=dt; }

  if(shake>0) shake=Math.max(0, shake - dt*SHAKE_DECAY);
}

// ---------- Draw ----------
function hudBanner(text,color="#fff"){
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.fillStyle="rgba(0,0,0,.65)"; ctx.fillRect(0,0,W,H);
  ctx.direction="ltr"; ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.fillStyle=color; ctx.font="bold 28px monospace"; ctx.fillText(text, W/2, H/2-12);
  const hint = IS_TOUCH ? "Tap to restart" : "Press R to restart";
  ctx.fillStyle="rgba(255,255,255,.85)"; ctx.font="16px monospace"; ctx.fillText(hint, W/2, H/2+22);
}

function drawGlowRect(x,y,w,h,blur,color,alpha=1){
  ctx.save();
  ctx.globalAlpha=alpha;
  ctx.shadowColor=color;
  ctx.shadowBlur=blur;
  ctx.fillStyle=color;
  ctx.fillRect(x,y,w,h);
  ctx.restore();
}
function drawEnemySpikes(cx,cy,r,arms=6,rot=0,color="#b687ff"){
  ctx.save(); ctx.translate(cx,cy); ctx.rotate(rot);
  ctx.beginPath();
  for(let i=0;i<arms;i++){
    const a = (i/arms)*Math.PI*2;
    ctx.moveTo(Math.cos(a)*r, Math.sin(a)*r);
    ctx.lineTo(Math.cos(a+0.08)*(r+8), Math.sin(a+0.08)*(r+8));
  }
  ctx.strokeStyle=color; ctx.lineWidth=2; ctx.stroke();
  ctx.restore();
}

function draw(){
  if(shake>0){ const sx=(Math.random()*2-1)*2*shake*60, sy=(Math.random()*2-1)*2*shake*60; ctx.setTransform(DPR,0,0,DPR,sx,sy); }
  else ctx.setTransform(DPR,0,0,DPR,0,0);

  ctx.fillStyle="#000"; ctx.fillRect(0,0,W,H);

  // stars
  ctx.fillStyle="rgba(255,255,255,.85)"; for(let i=0;i<stars.length;i++){ const s=stars[i]; ctx.fillRect(s.x,s.y,1,1); }

  // walls
  ctx.fillStyle=pal.wall; ctx.fillRect(0,0,W,8); ctx.fillRect(0,H-8,W,8); ctx.fillRect(0,0,8,H); ctx.fillRect(W-8,0,8,H);

  const dx=Math.sin(t*0.55)*18, dy=Math.sin(t*1.05)*3;

  // bricks
  for(let i=0;i<bricks.length;i++){ const b=bricks[i]; if(!b.alive) continue;
    const x=wordOffX + b.bx*wordScale + dx, y=wordOffY + b.by*wordScale + dy, bw=b.w*wordScale, bh=b.h*wordScale;
    ctx.fillStyle=pal.brick; ctx.fillRect(x,y,bw,bh);
    ctx.fillStyle="rgba(255,255,255,.12)"; ctx.fillRect(x+1,y+1,bw-2,2);
  }

  // debris
  for(let i=0;i<debris.length;i++){
    const d=debris[i];
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "rgba(255,120,120,.55)";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(d.px, d.py); ctx.lineTo(d.x, d.y); ctx.stroke();
    ctx.restore();

    ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(d.a||0);
    ctx.shadowColor = "rgba(255,60,60,.9)"; ctx.shadowBlur = 12;
    const s = Math.max(d.w, d.h);
    ctx.fillStyle = "#ff4a4a";
    ctx.beginPath();
    ctx.moveTo(0, -s*0.75); ctx.lineTo(s*0.6, 0); ctx.lineTo(0,  s*0.75); ctx.lineTo(-s*0.6,0);
    ctx.closePath(); ctx.fill();
    ctx.shadowBlur = 0; ctx.fillStyle = "rgba(255,240,240,.9)"; ctx.fillRect(-1,-1,2,2);
    ctx.restore();
  }

  // enemies
  for(let i=0;i<enemies.length;i++){
    const e=enemies[i];
    for(let j=0;j<e.trail.length;j++){
      const tr=e.trail[j]; if(tr.life<=0) continue;
      const a = Math.max(0, tr.life*3);
      drawGlowRect(tr.x-6,tr.y-4,12,8,6,"rgba(182,135,255,"+a*0.6+")", a*0.5);
    }
    const pulse = 1 + 0.22*Math.sin(t*6 + e.t*4);
    const ang = Math.atan2(e.vy, e.vx) + Math.PI/2;
    drawEnemySpikes(e.x, e.y, 10*pulse, 6, t*3, "rgba(255,80,120,.9)");
    drawGlowRect(e.x-8, e.y-6, 16, 12, 14, "rgba(182,135,255,.9)", 0.9);
    ctx.fillStyle=pal.enemy; ctx.fillRect(e.x-e.w/2, e.y-e.h/2, e.w, e.h);
    ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(ang); ctx.fillStyle="rgba(255,90,90,.9)"; ctx.fillRect(-2,-3,4,6); ctx.restore();
  }

  // --- POWERUPS: halo + pulse + icon (guarded gradient) ---
  for(let i=0;i<powerups.length;i++){
    const p=powerups[i];
    const baseX=p.x;
    const baseY=Number.isFinite(p.renderY) ? p.renderY : p.y;  // fallback safety
    const sc = 1 + 0.25*Math.sin(t*6 + (p.seed||0));
    const rad = 14*sc;

    if(Number.isFinite(baseX) && Number.isFinite(baseY) && Number.isFinite(rad) && rad>0){
      // halo
      const g = ctx.createRadialGradient(baseX,baseY,2, baseX,baseY,rad);
      const c1=(p.type==="shield")?"rgba(255,209,102,0.9)":"rgba(110,203,255,0.9)";
      const c2=(p.type==="shield")?"rgba(255,209,102,0.05)":"rgba(110,203,255,0.05)";
      g.addColorStop(0, c1);
      g.addColorStop(1, c2);
      ctx.fillStyle=g;
      ctx.beginPath(); ctx.arc(baseX,baseY,rad,0,Math.PI*2); ctx.fill();
    } else {
      // ultra-safe fallback: simple circle
      ctx.fillStyle=(p.type==="shield")?pal.powShield:pal.powRapid;
      ctx.beginPath(); ctx.arc(baseX||0,baseY||0,8,0,Math.PI*2); ctx.fill();
    }

    // glowing core
    ctx.save();
    ctx.translate(baseX, baseY); ctx.rotate((p.a||0)*0.7);
    ctx.shadowColor = (p.type==="shield")?"rgba(255,209,102,0.9)":"rgba(110,203,255,0.9)";
    ctx.shadowBlur = 18;
    ctx.fillStyle = (p.type==="shield")?pal.powShield:pal.powRapid;
    const w = p.w*sc, h = p.h*sc;

    if(p.type==="shield"){
      ctx.beginPath();
      ctx.moveTo(0, -h*0.9); ctx.lineTo(w*0.7, 0); ctx.lineTo(0,  h*0.9); ctx.lineTo(-w*0.7,0);
      ctx.closePath(); ctx.fill();
      ctx.shadowBlur = 0;
      ctx.fillStyle="#000"; ctx.fillRect(-1, -h*0.25, 2, h*0.22);
    }else{
      ctx.beginPath();
      ctx.moveTo(-w*0.7, -h*0.5); ctx.lineTo(0, 0); ctx.lineTo(-w*0.7, h*0.5); ctx.closePath(); ctx.fill();
      ctx.beginPath();
      ctx.moveTo(-w*0.2, -h*0.5); ctx.lineTo(w*0.5, 0); ctx.lineTo(-w*0.2, h*0.5); ctx.closePath(); ctx.fill();
    }
    ctx.restore();

    // small outline
    ctx.save();
    ctx.strokeStyle="rgba(255,255,255,0.5)";
    ctx.lineWidth=1;
    ctx.beginPath(); ctx.arc(baseX, baseY, (p.w+p.h)*0.5*0.55*(sc||1), 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  // particles
  for(let i=0;i<particles.length;i++){
    const p=particles[i];
    if(p.type==="flash"){ ctx.fillStyle="rgba(255,255,255,0.25)"; ctx.fillRect(p.x,p.y,p.w,p.h); continue; }
    ctx.globalAlpha=Math.max(0, p.life*1.2);
    ctx.fillStyle=p.col||"#fff";
    if(p.type==="shard"){ ctx.fillRect(p.x, p.y, p.sz||2, (p.sz||2)+1); }
    else{ ctx.fillRect(p.x, p.y, 2, 2); }
    ctx.globalAlpha=1;
  }

  // ship (flicker when invulnerable)
  if(invuln>0 && ((t*20|0)%2===0)) ctx.globalAlpha=0.35;
  ctx.fillStyle=pal.ship;
  ctx.beginPath(); ctx.moveTo(ship.x,ship.y-12); ctx.lineTo(ship.x-14,ship.y+10); ctx.lineTo(ship.x+14,ship.y+10); ctx.closePath(); ctx.fill();
  ctx.globalAlpha=1;
  if(hasShield){ ctx.strokeStyle=pal.powShield; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(ship.x,ship.y-2,18,0,Math.PI*2); ctx.stroke(); }

  // bullets
  for(let i=0;i<bullets.length;i++){ const bu=bullets[i]; ctx.globalAlpha=Math.max(0.4, bu.life); ctx.fillStyle=pal.bullet; ctx.fillRect(bu.x-1,bu.y,3,10); }
  ctx.globalAlpha=1;

  // HUD
  ctx.direction="ltr"; ctx.textAlign="left"; ctx.textBaseline="top";
  ctx.font="bold 20px monospace"; ctx.fillStyle="#cde4ff"; ctx.fillText("SCORE", 16, 12);
  ctx.font="bold 20px monospace"; ctx.fillStyle="#fff"; ctx.fillText(String(score).padStart(6,"0"), 16, 36);

  const heartW=12, gap=6; let hx=W - (heartW+gap)*lives - 16;
  for(let i=0;i<lives;i++){
    ctx.fillStyle="#ff5e5e";
    ctx.fillRect(hx+2,18+2,8,2); ctx.fillRect(hx,18+4,12,2); ctx.fillRect(hx+1,18+6,10,2); ctx.fillRect(hx+2,18+8,8,2);
    hx += heartW+gap;
  }

  ctx.font="16px monospace"; ctx.fillStyle="rgba(255,255,255,.8)";
  if(IS_TOUCH) ctx.fillText("DRAG TO MOVE • HOLD TO FIRE • TAP TO RESTART", 16, H-28);
  else ctx.fillText("ARROWS MOVE • SPACE FIRE • F FULLSCREEN • R RESTART", 16, H-28);

  if(state==="over") hudBanner("GAME OVER", "#ff5e5e");
  else if(state==="win" && winTimer>4) hudBanner("YOU WIN!", "#73eaff");
}

// ---------- Main loop ----------
function loop(ts){ const dt=Math.min(0.033,(ts-lastTs)/1000||0); lastTs=ts; update(dt); draw(); requestAnimationFrame(loop); }
requestAnimationFrame(loop);
</script>
</body>
</html>
