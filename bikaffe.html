<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>بكفي — Retro Space Shooter (v10+)</title>
<style>
  html,body{margin:0;height:100%;background:#000;color:#e7eefc}
  #stage{position:fixed; inset:0; overflow:hidden; touch-action:none}
  canvas{display:block; width:100vw; height:100vh; background:#000; image-rendering:pixelated; direction:ltr}
  .crt{position:absolute; inset:0; pointer-events:none;
       background:repeating-linear-gradient(to bottom, rgba(255,255,255,.03) 0 1px, rgba(0,0,0,0) 1px 3px);
       mix-blend-mode:overlay;}
</style>
</head>
<body>
<div id="stage">
  <canvas id="game"></canvas>
  <div class="crt"></div>
</div>

<script>
/* ============================================================
   بكفي — Retro Space Shooter (v10+ tweaks)
   - Threat visuals for debris & enemies (glow, trails, spikes, pulsing core)
   - Word higher, player a bit higher (thumb-safe)
   - Everything else unchanged
============================================================ */

// ---------- Canvas ----------
const stage=document.getElementById('stage');
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d', {alpha:true, willReadFrequently:true});
let DPR=1, W=960, H=540;

function resize(){
  DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  W = Math.floor(window.innerWidth); H = Math.floor(window.innerHeight);
  canvas.width = Math.floor(W*DPR); canvas.height = Math.floor(H*DPR);
  canvas.style.width=W+"px"; canvas.style.height=H+"px";
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.imageSmoothingEnabled=false;
  layoutWordFit();
}
addEventListener('resize', resize);

// ---------- Env & tuning ----------
const IS_TOUCH=('ontouchstart' in window)||navigator.maxTouchPoints>0||matchMedia('(pointer: coarse)').matches;
const pal={ wall:"#1b2030", brick:"#ff3b3b", ship:"#aef59a", bullet:"#ffffff",
            debris:"#ff3b3b", enemy:"#b687ff", powRapid:"#6ecbff", powShield:"#ffd166" };

const BASE_BLOCK=12, BASE_GAP=1, CELL=BASE_BLOCK+BASE_GAP;
// const TOP_FRACTION=0.15;
const TOP_FRACTION=0.09;                         // [CHANGED] move word higher

const SHIP_MAX_SPEED=520, SHIP_ACCEL=3000, SHIP_FRICTION=2200;
const BASE_COOLDOWN=0.12, RAPID_COOLDOWN=0.06;

const DEBRIS_CHANCE=0.20;
const DROP_CHANCE=0.10;

const SHAKE_HIT=0.01, SHAKE_DECAY=1.4;

const ENEMY_MIN_INTERVAL=IS_TOUCH?2.8:2.4;
const ENEMY_MAX_INTERVAL=IS_TOUCH?4.6:4.0;
const ENEMY_MAX_ACTIVE=IS_TOUCH?4:5;

// --- NEW: make player sit a bit higher, responsive to screen height ---
const SHIP_PAD_FRAC = IS_TOUCH ? 0.20 : 0.18;    // [NEW] 20% (touch) / 18% (desktop) from bottom
function shipBaselineY(){ return Math.round(H * (1 - SHIP_PAD_FRAC)); }

// ---------- State ----------
let stars=[], bricks=[], bullets=[], debris=[], particles=[], enemies=[], powerups=[];
let ship, score=0, lives=5, state="play", t=0, lastTs=0, shake=1, winTimer=0, rapidTime=0, hasShield=false;
const keys={}; let pointerDown=false, pointerX=null, lastTap=0;

// ---------- Offscreen word raster ("بكفي") ----------
const fontStack='"Noto Naskh Arabic","Scheherazade New","Amiri","Segoe UI Historic","Arial","sans-serif"';
let baseBricks=[], baseWidth=1, baseHeight=1, minC=0, minR=0;

function buildWordGrid(word="بكفي"){
  baseBricks.length=0;
  const off=document.createElement('canvas'); off.width=1600; off.height=520;
  const g=off.getContext('2d', {alpha:true, willReadFrequently:true});

  g.clearRect(0,0,off.width,off.height);
  g.fillStyle="#fff"; g.textAlign="center"; g.textBaseline="middle"; g.direction="rtl";
  g.font=`bold 360px ${fontStack}`;
  g.fillText(word, off.width/2, off.height/2 + 6);

  const data=g.getImageData(0,0,off.width,off.height).data;
  const cols=Math.floor(off.width/CELL), rows=Math.floor(off.height/CELL);

  let cMin=cols, rMin=rows, cMax=-1, rMax=-1;
  const occupied=[];
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const baseX=c*CELL, baseY=r*CELL;
      const samples=[[0.5,0.5],[0.2,0.5],[0.8,0.5],[0.5,0.2],[0.5,0.8]];
      let on=false;
      for(const [ux,uy] of samples){
        const px=Math.min(off.width-1, Math.floor(baseX + ux*BASE_BLOCK));
        const py=Math.min(off.height-1, Math.floor(baseY + uy*BASE_BLOCK));
        const a=data[(py*off.width+px)*4+3];
        if(a>32){ on=true; break; }
      }
      if(on){
        occupied.push({c,r});
        if(c<cMin) cMin=c; if(r<rMin) rMin=r;
        if(c>cMax) cMax=c; if(r>rMax) rMax=r;
      }
    }
  }

  if(occupied.length<50){
    occupied.length=0; cMin=cols; rMin=rows; cMax=-1; rMax=-1;
    g.clearRect(0,0,off.width,off.height);
    g.fillStyle="#fff"; g.font=`bold 420px ${fontStack}`;
    g.fillText(word, off.width/2, off.height/2 + 8);
    const d2=g.getImageData(0,0,off.width,off.height).data;
    for(let r=0;r<rows;r++)for(let c=0;c<cols;c++){
      const px=Math.min(off.width-1, Math.floor(c*CELL + BASE_BLOCK*0.5));
      const py=Math.min(off.height-1, Math.floor(r*CELL + BASE_BLOCK*0.5));
      if(d2[(py*off.width+px)*4+3]>16){
        occupied.push({c,r});
        if(c<cMin) cMin=c; if(r<rMin) rMin=r;
        if(c>cMax) cMax=c; if(r>rMax) rMax=r;
      }
    }
  }

  minC=cMin; minR=rMin;
  baseBricks = occupied.map(({c,r})=>({
    x:(c-minC)*CELL, y:(r-minR)*CELL, w:BASE_BLOCK, h:BASE_BLOCK, alive:true, flash:0
  }));
  baseWidth  = (cMax - cMin + 1) * CELL;
  baseHeight = (rMax - rMin + 1) * CELL;

  if(!isFinite(baseWidth)||baseWidth<=0){ baseWidth=BASE_BLOCK*10; baseHeight=BASE_BLOCK*6; }
}

// fit & placement
let wordScale=1, wordOffX=0, wordOffY=0;
function layoutWordFit(){
  if(!baseWidth) return;
  const fitW=W*0.92, fitH=H*(IS_TOUCH?0.50:0.55);
  wordScale = Math.min(fitW/baseWidth, fitH/baseHeight);
  const top=Math.floor(H*TOP_FRACTION);
  const wpx=baseWidth*wordScale, hpx=baseHeight*wordScale;
  wordOffX=Math.floor((W-wpx)/2);
  wordOffY=Math.floor(top + (fitH-hpx)/2);
}
function instantiateBricks(){ bricks = baseBricks.map(b=>({bx:b.x,by:b.y,w:b.w,h:b.h,alive:true,flash:0})); }

// ---------- Helpers ----------
function rectHit(ax,ay,aw,ah,bx,by,bw,bh){return ax<bx+bw&&ax+aw>bx&&ay<by+bh&&ay+ah>by;}

// ---------- Stars ----------
function buildStars(){ stars.length=0; const n=Math.round((W*H)/9000); for(let i=0;i<n;i++) stars.push({x:Math.random()*W,y:Math.random()*H,z:Math.random()*2+0.5}); }

// ---------- Enemies & Powerups ----------
let enemyTimer=0;
function nextEnemyTime(){ return ENEMY_MIN_INTERVAL + Math.random()*(ENEMY_MAX_INTERVAL-ENEMY_MIN_INTERVAL); }
function spawnEnemy(){
  const side=Math.random()<0.5?-40:W+40, y=30+Math.random()*60, dir=side<0?1:-1;
  enemies.push({x:side,y,w:16,h:12,vx:80*dir,vy:24,state:"home",t:0,alive:true, trail:[]}); // [CHANGED] add trail array
}
function dropPowerup(x,y){
  const type=Math.random()<0.5?"shield":"rapid";
  powerups.push({x,y,w:10,h:10,vy:120+Math.random()*80,vx:(Math.random()*50-25),type,alive:true,a:0});
}

// ---------- Audio ----------
let audioCtx;
function blip(f=440,d=0.05){try{
  audioCtx=audioCtx||new (window.AudioContext||window.webkitAudioContext)();
  const o=audioCtx.createOscillator(), g=audioCtx.createGain();
  o.type="square"; o.frequency.value=f; g.gain.value=0.05; o.connect(g); g.connect(audioCtx.destination);
  o.start(); g.gain.exponentialRampToValueAtTime(0.0001,audioCtx.currentTime+d); o.stop(audioCtx.currentTime+d);
}catch{}}

// ---------- Reset / Init ----------
function hardReset(){
  score=0; lives=5; state="play"; t=0; shake=0; winTimer=0; rapidTime=0; hasShield=false;
  ship={x:W/2,y:shipBaselineY(),w:28,h:18,vx:0,cooldown:0};                        // [CHANGED]
  instantiateBricks(); buildStars();
  bullets.length=debris.length=particles.length=enemies.length=powerups.length=0;
  enemyTimer=nextEnemyTime();
}
function init(){
  resize();
  buildWordGrid("بكفي");
  layoutWordFit();
  hardReset();
}
document.addEventListener('DOMContentLoaded', init);

// ---------- Input ----------
addEventListener('keydown',e=>{
  keys[e.code]=true; if(e.code==='Space') e.preventDefault();
  if(e.code==='KeyR') hardReset();
  if(e.code==='KeyF'){ if(!document.fullscreenElement) stage.requestFullscreen?.(); else document.exitFullscreen?.(); }
});
addEventListener('keyup',e=>keys[e.code]=false);
stage.addEventListener('pointerdown',e=>{
  const now=performance.now();
  if(now-lastTap<300){ if(!document.fullscreenElement) stage.requestFullscreen?.(); else document.exitFullscreen?.(); }
  lastTap=now; pointerDown=true; pointerX=e.clientX; stage.setPointerCapture?.(e.pointerId);
});
stage.addEventListener('pointermove',e=>{ if(pointerDown) pointerX=e.clientX; });
stage.addEventListener('pointerup',e=>{ pointerDown=false; pointerX=null; });
stage.addEventListener('click',()=>{ if(state==="over" || (state==="win" && winTimer>4)) hardReset(); });

// ---------- Game update ----------
function hitPlayer(){
  if(hasShield){ hasShield=false; blip(180,.08); return; }
  lives--; blip(120,.12); shake=Math.max(shake, SHAKE_HIT*1.5);
  if(lives<=0) state="over"; else { ship.x=W/2; ship.vx=0; bullets.length=0; }
}

function collectPowerup(p){ if(p.type==="shield") hasShield=true; else rapidTime=8.0; }

function update(dt){
  if(state!=="play" && state!=="win") return;
  t+=dt;

  // stars
  for(const s of stars){ s.y += (state==="win"?10:20)*s.z*dt; if(s.y>H) s.y-=H; }

  // ship movement (keys + touch)
  let target=0; if(keys.ArrowLeft||keys.KeyA)target-=1; if(keys.ArrowRight||keys.KeyD)target+=1;
  if(pointerDown && pointerX!=null){ const dx=(pointerX-ship.x); target=Math.sign(dx); ship.vx+=Math.max(-SHIP_ACCEL*dt,Math.min(SHIP_ACCEL*dt,dx*4)); }
  const desired=target*SHIP_MAX_SPEED, delta=desired-ship.vx, accel=(target?SHIP_ACCEL:SHIP_FRICTION)*dt;
  ship.vx += Math.max(-accel, Math.min(accel, delta));
  if(!target && !pointerDown){ const s=Math.sign(ship.vx); ship.vx -= s*Math.min(Math.abs(ship.vx), SHIP_FRICTION*dt*0.6); }
  ship.x=Math.max(20,Math.min(W-20, ship.x + ship.vx*dt));
  ship.y = shipBaselineY();                                                    // [CHANGED] keep higher baseline

  // shooting
  const cd = rapidTime>0 ? RAPID_COOLDOWN : BASE_COOLDOWN;
  if(ship.cooldown>0) ship.cooldown-=dt;
  if(state==="play" && ship.cooldown<=0 && (keys.Space || pointerDown)){
    bullets.push({x:ship.x,y:ship.y-12,w:3,h:10,vy:-700,life:1});
    ship.cooldown=cd; blip(900,.05);
  }
  if(rapidTime>0) rapidTime-=dt;

  // bullets
  for(const b of bullets){ b.y+=b.vy*dt; b.life-=dt*0.9; }
  bullets=bullets.filter(b=>b.y>-20 && b.life>0);

  // word drift
  const wdx=Math.sin(t*0.55)*18, wdy=Math.sin(t*1.05)*3;

  // bullet vs bricks
  for(const br of bricks){
    if(!br.alive) continue;
    const bx=wordOffX + br.bx*wordScale + wdx;
    const by=wordOffY + br.by*wordScale + wdy;
    const bw=br.w*wordScale, bh=br.h*wordScale;

    for(const bu of bullets){
      if(bu.x>bx && bu.x<bx+bw && bu.y>by && bu.y<by+bh){
        br.alive=false; bu.y=-9999; score+=10; blip(240,.04); shake=Math.min(0.06, shake+SHAKE_HIT);

        // flash + shards + sparks (existing)
        particles.push({x:bx,y:by,w:bw,h:bh,type:"flash",life:.08});
        for(let i=0;i<6;i++){
          const ang=Math.random()*6.283, spd=140+Math.random()*220, sz=1+Math.random()*2;
          particles.push({x:bx+bw/2,y:by+bh/2,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,sz,life:.5+Math.random()*.35,col:pal.brick,type:"shard"});
        }
        for(let i=0;i<10;i++){
          const ang=Math.random()*6.283, spd=90+Math.random()*160;
          particles.push({x:bx+bw/2,y:by+bh/2,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,life:.55+Math.random()*.35,col:i%2?pal.brick:"#ffd7d7",type:"pix"});
        }

        if(Math.random()<DEBRIS_CHANCE)
          debris.push({x:bx+bw/2,y:by+bh/2,w:7,h:7,vy:220+Math.random()*190,vx:(Math.random()*90-45),a:0,spin:(Math.random()*.4-.2),alive:true,px:bx+bw/2,py:by+bh/2}); // [CHANGED] sharper & faster, store px/py
        if(Math.random()<DROP_CHANCE) dropPowerup(bx+bw/2, by+bh/2);
      }
    }
  }

  // debris (store previous position for trail)
  for(const d of debris){
    d.px = d.x; d.py = d.y;                                              // [NEW] keep previous pos
    d.x+=d.vx*dt; d.y+=d.vy*dt; d.a+=d.spin;
    if(state==="play" && rectHit(ship.x-12,ship.y-10,24,20,d.x-d.w/2,d.y-d.h/2,d.w,d.h)){ d.alive=false; hitPlayer(); }
  }
  debris=debris.filter(d=>d.alive && d.y<H+20);

  // powerups
  for(const p of powerups){ p.x+=p.vx*dt; p.y+=p.vy*dt; p.a=(p.a||0)+0.08;
    if(rectHit(ship.x-12,ship.y-10,24,20,p.x-p.w/2,p.y-p.h/2,p.w,p.h)){ p.alive=false; collectPowerup(p); blip(700,.06); } }
  powerups=powerups.filter(p=>p.alive && p.y<H+20);

  // enemies (home -> dive)
  if(state==="play"){ enemyTimer-=dt; if(enemyTimer<=0 && enemies.filter(e=>e.alive).length<ENEMY_MAX_ACTIVE){ spawnEnemy(); enemyTimer=nextEnemyTime(); } }
  for(const e of enemies){
    if(!e.alive) continue; e.t+=dt;

    // keep a short trail of previous positions (threatening afterimage) --- [NEW]
    e.trail.push({x:e.x,y:e.y,life:0.25});
    if(e.trail.length>10) e.trail.shift();
    for(const tr of e.trail) tr.life -= dt;

    const dx=ship.x-e.x, dy=(ship.y-40)-e.y, dist=Math.hypot(dx,dy)+1e-3, ux=dx/dist, uy=dy/dist;
    if(e.state==="home"){ e.vx+=ux*80*dt; e.vy+=uy*60*dt; if(e.t>1.1 && Math.random()<0.02) e.state="dive"; }
    else { e.vx+=ux*130*dt; e.vy+=uy*170*dt; }
    const sp=Math.hypot(e.vx,e.vy), max=(e.state==="dive"?240:165); if(sp>max){ e.vx=e.vx/sp*max; e.vy=e.vy/sp*max; } // [CHANGED] slightly faster when diving
    e.x+=e.vx*dt; e.y+=e.vy*dt; if(e.x<-60||e.x>W+60||e.y>H+60) e.alive=false;

    // bullet hit
    for(const bu of bullets){
      if(bu.x>e.x-e.w/2&&bu.x<e.x+e.w/2&&bu.y>e.y-e.h/2&&bu.y<e.y+e.h/2){
        e.alive=false; bu.y=-9999; score+=15; blip(300,.05); shake=Math.min(0.06, shake+SHAKE_HIT*0.8);
        for(let i=0;i<14;i++){ const a=Math.random()*6.283, spd=100+Math.random()*180; particles.push({x:e.x,y:e.y,vx:Math.cos(a)*spd,vy:Math.sin(a)*spd,life:.5+Math.random()*.4,col:pal.enemy,type:"pix"}); }
        if(Math.random()<0.08) dropPowerup(e.x,e.y);
      }
    }
    if(state==="play" && rectHit(ship.x-12,ship.y-10,24,20,e.x-e.w/2,e.y-e.h/2,e.w,e.h)){ e.alive=false; hitPlayer(); }
  }
  enemies=enemies.filter(e=>e.alive);

  // particles sim
  for(const p of particles){
    if(p.type==="flash"){ p.life-=dt; continue; }
    p.x+=p.vx*dt; p.y+=p.vy*dt; p.vy += (p.type==="shard"?120:40)*dt;
    p.life-=dt;
  }
  particles=particles.filter(p=>p.life>0);

  // win?
  if(state==="play" && !bricks.some(b=>b.alive)){ state="win"; winTimer=0; blip(660,.1); blip(990,.12); }
  if(state==="win"){ winTimer+=dt; }

  if(shake>0) shake=Math.max(0, shake - dt*SHAKE_DECAY);
}

// ---------- Draw ----------
function hudBanner(text,color="#fff"){
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.fillStyle="rgba(0,0,0,.65)"; ctx.fillRect(0,0,W,H);
  ctx.direction="ltr"; ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.fillStyle=color; ctx.font="bold 28px monospace"; ctx.fillText(text, W/2, H/2-12);
  const hint = IS_TOUCH ? "Tap to restart" : "Press R to restart";
  ctx.fillStyle="rgba(255,255,255,.85)"; ctx.font="16px monospace"; ctx.fillText(hint, W/2, H/2+22);
}

// --- helpers for threat shapes [NEW] ---
function drawGlowRect(x,y,w,h,blur,color,alpha=1){
  ctx.save();
  ctx.globalAlpha=alpha;
  ctx.shadowColor=color;
  ctx.shadowBlur=blur;
  ctx.fillStyle=color;
  ctx.fillRect(x,y,w,h);
  ctx.restore();
}
function drawEnemySpikes(cx,cy,r,arms=6,rot=0,color="#b687ff"){
  ctx.save();
  ctx.translate(cx,cy);
  ctx.rotate(rot);
  ctx.beginPath();
  for(let i=0;i<arms;i++){
    const a = (i/arms)*Math.PI*2;
    ctx.moveTo(Math.cos(a)*r, Math.sin(a)*r);
    ctx.lineTo(Math.cos(a+0.08)*(r+8), Math.sin(a+0.08)*(r+8));
  }
  ctx.strokeStyle=color;
  ctx.lineWidth=2;
  ctx.stroke();
  ctx.restore();
}

function draw(){
  if(shake>0){ const sx=(Math.random()*2-1)*2*shake*60, sy=(Math.random()*2-1)*2*shake*60; ctx.setTransform(DPR,0,0,DPR,sx,sy); }
  else ctx.setTransform(DPR,0,0,DPR,0,0);

  ctx.fillStyle="#000"; ctx.fillRect(0,0,W,H);

  // stars
  ctx.fillStyle="rgba(255,255,255,.85)"; for(const s of stars) ctx.fillRect(s.x,s.y,1,1);

  // walls
  ctx.fillStyle=pal.wall; ctx.fillRect(0,0,W,8); ctx.fillRect(0,H-8,W,8); ctx.fillRect(0,0,8,H); ctx.fillRect(W-8,0,8,H);

  const dx=Math.sin(t*0.55)*18, dy=Math.sin(t*1.05)*3;

  // bricks
  for(const b of bricks){ if(!b.alive) continue;
    const x=wordOffX + b.bx*wordScale + dx, y=wordOffY + b.by*wordScale + dy, bw=b.w*wordScale, bh=b.h*wordScale;
    ctx.fillStyle=pal.brick; ctx.fillRect(x,y,bw,bh);
    ctx.fillStyle="rgba(255,255,255,.12)"; ctx.fillRect(x+1,y+1,bw-2,2);
  }

  // debris — glow, trail, diamond shape (feels hot)  [CHANGED]
  for(const d of debris){
    // trail
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "rgba(255,120,120,.55)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(d.px, d.py);
    ctx.lineTo(d.x, d.y);
    ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.translate(d.x, d.y);
    ctx.rotate(d.a||0);

    // glow
    ctx.shadowColor = "rgba(255,60,60,.9)";
    ctx.shadowBlur = 12;

    // diamond
    const s = Math.max(d.w, d.h);
    ctx.fillStyle = "#ff4a4a";
    ctx.beginPath();
    ctx.moveTo(0, -s*0.75);
    ctx.lineTo(s*0.6, 0);
    ctx.lineTo(0,  s*0.75);
    ctx.lineTo(-s*0.6,0);
    ctx.closePath();
    ctx.fill();

    // white-hot core
    ctx.shadowBlur = 0;
    ctx.fillStyle = "rgba(255,240,240,.9)";
    ctx.fillRect(-1,-1,2,2);
    ctx.restore();
  }

  // enemies — pulsing core, spikes, glow, afterimage trail  [CHANGED]
  for(const e of enemies){
    // afterimage
    for(const tr of e.trail){
      if(tr.life<=0) continue;
      const a = Math.max(0, tr.life*3);
      drawGlowRect(tr.x-6,tr.y-4,12,8,6,"rgba(182,135,255,"+a*0.6+")", a*0.5);
    }

    const pulse = 1 + 0.22*Math.sin(t*6 + e.t*4);
    const ang = Math.atan2(e.vy, e.vx) + Math.PI/2;

    // spikes
    drawEnemySpikes(e.x, e.y, 10*pulse, 6, t*3, "rgba(255,80,120,.9)");

    // body glow
    drawGlowRect(e.x-8, e.y-6, 16, 12, 14, "rgba(182,135,255,.9)", 0.9);

    // body
    ctx.fillStyle=pal.enemy;
    ctx.fillRect(e.x-e.w/2, e.y-e.h/2, e.w, e.h);

    // "eye" core
    ctx.save();
    ctx.translate(e.x, e.y);
    ctx.rotate(ang);
    ctx.fillStyle="rgba(255,90,90,.9)";
    ctx.fillRect(-2,-3,4,6);
    ctx.restore();
  }

  // powerups
  for(const p of powerups){ ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.a||0); ctx.fillStyle=(p.type==="shield"?pal.powShield:pal.powRapid); ctx.fillRect(-p.w/2,-p.h/2,p.w,p.h); ctx.restore(); }

  // particles
  for(const p of particles){
    if(p.type==="flash"){ ctx.fillStyle="rgba(255,255,255,0.25)"; ctx.fillRect(p.x,p.y,p.w,p.h); continue; }
    ctx.globalAlpha=Math.max(0, p.life*1.2);
    ctx.fillStyle=p.col||"#fff";
    if(p.type==="shard"){ ctx.fillRect(p.x, p.y, p.sz||2, (p.sz||2)+1); }
    else{ ctx.fillRect(p.x, p.y, 2, 2); }
    ctx.globalAlpha=1;
  }

  // ship
  ctx.fillStyle=pal.ship;
  ctx.beginPath(); ctx.moveTo(ship.x,ship.y-12); ctx.lineTo(ship.x-14,ship.y+10); ctx.lineTo(ship.x+14,ship.y+10); ctx.closePath(); ctx.fill();
  if(hasShield){ ctx.strokeStyle=pal.powShield; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(ship.x,ship.y-2,18,0,Math.PI*2); ctx.stroke(); }

  // bullets
  ctx.fillStyle=pal.bullet; for(const bu of bullets) ctx.fillRect(bu.x-1,bu.y,3,10);

  // HUD (LTR)
  ctx.direction="ltr"; ctx.textAlign="left"; ctx.textBaseline="top";
  ctx.font="bold 20px monospace"; ctx.fillStyle="#cde4ff"; ctx.fillText("SCORE", 16, 12);
  ctx.font="bold 20px monospace"; ctx.fillStyle="#fff"; ctx.fillText(String(score).padStart(6,"0"), 16, 36);

  const heartW=12, gap=6; let hx=W - (heartW+gap)*lives - 16;
  for(let i=0;i<lives;i++){
    ctx.fillStyle="#ff5e5e";
    ctx.fillRect(hx+2,18+2,8,2); ctx.fillRect(hx,18+4,12,2); ctx.fillRect(hx+1,18+6,10,2); ctx.fillRect(hx+2,18+8,8,2);
    hx += heartW+gap;
  }

  ctx.font="16px monospace"; ctx.fillStyle="rgba(255,255,255,.8)";
  if(IS_TOUCH) ctx.fillText("DRAG TO MOVE • HOLD TO FIRE • TAP TO RESTART", 16, H-28);
  else ctx.fillText("ARROWS MOVE • SPACE FIRE • F FULLSCREEN • R RESTART", 16, H-28);

  if(state==="over") hudBanner("GAME OVER", "#ff5e5e");
  else if(state==="win" && winTimer>4) hudBanner("YOU WIN!", "#73eaff");
}

// ---------- Main loop ----------
function loop(ts){ const dt=Math.min(0.033,(ts-lastTs)/1000||0); lastTs=ts; update(dt); draw(); requestAnimationFrame(loop); }
requestAnimationFrame(loop);
</script>
</body>
</html>
